# Модуль полнодуплексного последовательного обмена

## Структура репозитория

* [modules](https://github.com/alexmangushev/serial_full_duplex_module/tree/master/modules) - описание модулей
* [testbenches](https://github.com/alexmangushev/serial_full_duplex_module/tree/master/testbenches) - тестбенчи
* [TOP](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/modules/TOP.v) - главный файл проекта
* [test_TOP](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/testbenches/test_TOP.v) - тестбенч для главного файла

При разработке быле решено выделить алгоритмы приема и передачи в отдельные 
модули([tx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/modules/tx_fsm.v) 
и [rx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/modules/rx_fsm.v)), которые объеденины в модуле верхнего уровня. 
Для модулей [tx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/modules/tx_fsm.v)
и [rx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/modules/rx_fsm.v) 
составлены собственные тесты ([test_tx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/testbenches/test_tx_fsm.v)
и [test_rx_fsm](https://github.com/alexmangushev/serial_full_duplex_module/blob/master/testbenches/test_rx_fsm.v).

Для запуска проекта необходимо открыть файл проекта (.qpf) с помощью среды разработки Quartus.

Разработка проекта велась в среде Quartus II 13.1 Web Edition. Запуск тестбенчей производился с помощью ModelSim_Altera.
Проект настроен на взаимодействие именно с этим симулятором. Перед проверкой модуля выбираем соответствующий тестбенч в настройках проекта.

Все тестбенчи пишут в консоль результат тестирования и информируют об ошибках, связанных с неверным результатом передачи/приема, 
а также с неправильными таймингами на заданных выходах. 

В ходе разработки модулей была применена параметризация, 
позволяющая без особых вмешательств в код изменить размерность передаваемых данных.

## Задание: Разработка модуля полнодуплексного последовательного обмена.

Разработать сам модуль и разработать модуль его тестирования.

## Интерфейс модуля 
**Таблица 1. Интерфейс модуля**

| Название сигнала | Размерность | Направление | Описание |
| ---------------- | ----------- | ----------- | -------- |
| sck_rx	       |    1	     |   Выход	   | Сигнал тактирования чтения |
| data_rx	       |    1	     |   Вход	   | Сигнал входных данных |
| receive_data	   |    32	     |   Выход	   | Регистр принятых данных |
| sck_tx	       |    1	     |   Выход	   | Сигнал тактирования записи |
| data_tx	       |    1	     |   Выход	   | Сигнал выходных данных |
| transmit_data	   |    32	     |   Вход	   | Шина данных для передачи |
| latch_flag	   |    1	     |   Выход	   | Сигнал разрешения записи/Чтения |
| clk	           |    1	     |   Вход	   | Сигнал тактирование модуля |
| rst	           |    1	     |   Вход	   | Сигнал сброса модуля |
| start	           |    1	     |   Вход	   | Сигнала начала работы |
| finish	       |    1	     |   Выход	   | Сигнал окончания работы |
| busy	           |    1	     |   Выход	   | Сигнал «модуль занят» |
| mode	           |    1	     |   Вход	   | Выбор режима чтение / запись |

## Работа модуля 

- Сброс асинхронный, активный уровень – лог. 0.
- Тактирование модуль: 1 МГц.

Состояние при сбросе: все выходы находятся в лог. 0.

При установке на линии start лог. 1 длительностью не менее двух тактов clk модуль выполняет алгоритм приема или передачи (в зависимости от режима). После обнаружения сигнала начала работы модуль выставляет лог. 1 на линии busy. После окончания приема или передачи модуль устанавливает на линии finish лог. 1 длительностью 5 тактов, после чего состояние модуля сбрасывается в состояние, аналогичную сбросу.

Если mode == 0 – модуль выполняет передачу данных, установленных на шине transmit_data.

Если mode == 1 – модуль выполняет прием данных и записывает их в регистр receive_data.

## Алгоритм передачи модуля
Передача производится старшим битом вперед.
1) Устанавливаем на линии data_tx очередной бит с шины transmit_data.
2) На следующий такт clk устанавливаем на линии sck_tx лог. 1 на один такт clk.
3) Устанавливаем на линии sck_tx лог. 0 на один такт clk.
4) Повторяем шаги 1-3 для каждого бита шины transmit_data.
5) Устанавливаем лог. 1 на линии latch_flag.
6) На следующий такт устанавливаем на линии sck_tx лог. 1 на один такт clk.
7) Устанавливаем на линии sck_tx лог. 0 на один такт clk.
8) Устанавливаем лог. 0 на линии latch_flag.

## Алгоритм приема модуля
1) Устанавливаем лог. 1 на линии latch_flag.
2) На следующий такт устанавливаем на линии sck_rx лог. 1 на один такт clk.
3) Устанавливаем на линии sck_rx лог. 0 на один такт clk.
4) Устанавливаем лог. 0 на линии latch_flag.
5) Считываем очередной бит с линии data_rx в регистр receive_data и сдвигаем его вправо.
6) Устанавливаем на линии sck_rx лог. 1 на один такт clk.
7) Устанавливаем на линии sck_rx лог. 0 на один такт clk.
8) Повторяем шаги 5-7 для каждого бита.
